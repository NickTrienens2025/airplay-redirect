<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitor - AirPlay HLS Proxy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f1419;
            min-height: 100vh;
            color: #e7e9ea;
        }
        .header {
            background: linear-gradient(135deg, #1a1f2e 0%, #252d3d 100%);
            padding: 20px 30px;
            border-bottom: 1px solid #38444d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            font-size: 1.5em;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .header h1 .icon {
            font-size: 1.2em;
        }
        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-clear {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }
        .btn-clear:hover {
            background: rgba(244, 67, 54, 0.3);
        }
        .status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            padding: 8px 16px;
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
        }
        .status-badge.connected {
            background: rgba(0, 200, 83, 0.2);
            color: #00c853;
        }
        .status-badge.disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .container {
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .card {
            background: #1a1f2e;
            border-radius: 12px;
            border: 1px solid #38444d;
            overflow: hidden;
        }
        .card-header {
            padding: 16px 20px;
            border-bottom: 1px solid #38444d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .card-header h2 {
            font-size: 1em;
            font-weight: 600;
            color: #8899a6;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .card-body {
            padding: 20px;
        }
        .stat-value {
            font-size: 3em;
            font-weight: 700;
            color: #fff;
            line-height: 1;
        }
        .stat-label {
            font-size: 0.85em;
            color: #8899a6;
            margin-top: 8px;
        }
        .stat-change {
            font-size: 0.9em;
            margin-top: 4px;
        }
        .stat-change.positive {
            color: #00c853;
        }
        .stat-change.negative {
            color: #f44336;
        }
        .sessions-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .session-item {
            padding: 16px;
            border-bottom: 1px solid #38444d;
            transition: background 0.2s;
            cursor: pointer;
        }
        .session-item:last-child {
            border-bottom: none;
        }
        .session-item:hover {
            background: rgba(255,255,255,0.05);
        }
        .session-item.selected {
            background: rgba(29, 161, 242, 0.1);
            border-left: 3px solid #1da1f2;
        }
        .session-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        .session-id {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85em;
            color: #1da1f2;
            background: rgba(29, 161, 242, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
        }
        .session-status {
            font-size: 0.75em;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
        }
        .session-status.active {
            background: rgba(0, 200, 83, 0.2);
            color: #00c853;
        }
        .session-status.expiring {
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
        }
        .session-status.demo {
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
        }
        .session-details {
            font-size: 0.85em;
            color: #8899a6;
        }
        .session-details p {
            margin: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .session-details .label {
            color: #657786;
            min-width: 80px;
        }
        .session-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .session-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(29, 161, 242, 0.2);
            color: #1da1f2;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.8em;
            font-weight: 500;
            transition: background 0.2s;
        }
        .session-link:hover {
            background: rgba(29, 161, 242, 0.3);
        }
        .session-link.copy {
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
            cursor: pointer;
        }
        .session-link.copy:hover {
            background: rgba(156, 39, 176, 0.3);
        }
        .traffic-feed {
            max-height: 500px;
            overflow-y: auto;
        }
        .traffic-item {
            padding: 12px 16px;
            border-bottom: 1px solid #38444d;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8em;
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }
        .traffic-item:last-child {
            border-bottom: none;
        }
        .traffic-item.error {
            background: rgba(244, 67, 54, 0.05);
        }
        .traffic-time {
            color: #657786;
            white-space: nowrap;
        }
        .traffic-method {
            font-weight: 600;
            min-width: 40px;
        }
        .traffic-method.GET { color: #4caf50; }
        .traffic-method.POST { color: #ff9800; }
        .traffic-method.PUT { color: #2196f3; }
        .traffic-method.DELETE { color: #f44336; }
        .traffic-path {
            color: #e7e9ea;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .traffic-status {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .traffic-status.s2xx { background: rgba(76, 175, 80, 0.2); color: #4caf50; }
        .traffic-status.s3xx { background: rgba(33, 150, 243, 0.2); color: #2196f3; }
        .traffic-status.s4xx { background: rgba(255, 152, 0, 0.2); color: #ff9800; }
        .traffic-status.s5xx { background: rgba(244, 67, 54, 0.2); color: #f44336; }
        .traffic-size {
            color: #8899a6;
            min-width: 70px;
            text-align: right;
        }
        .traffic-token {
            color: #ce93d8;
            font-size: 0.85em;
        }
        .chart-container {
            height: 200px;
            display: flex;
            align-items: flex-end;
            gap: 4px;
            padding: 20px 0;
        }
        .chart-bar {
            flex: 1;
            background: linear-gradient(180deg, #1da1f2 0%, rgba(29, 161, 242, 0.3) 100%);
            border-radius: 4px 4px 0 0;
            min-height: 4px;
            transition: height 0.3s ease;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 16px;
        }
        .metric-item {
            text-align: center;
            padding: 16px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: 600;
            color: #fff;
        }
        .metric-label {
            font-size: 0.75em;
            color: #8899a6;
            margin-top: 4px;
        }
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #657786;
        }
        .empty-state .icon {
            font-size: 3em;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        .nav-link {
            color: #1da1f2;
            text-decoration: none;
            font-size: 0.9em;
        }
        .nav-link:hover {
            text-decoration: underline;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background: #1a1f2e;
            border: 1px solid #38444d;
            border-radius: 8px;
            color: #fff;
            font-size: 0.9em;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            z-index: 1000;
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        .toast.success {
            border-color: #00c853;
            background: rgba(0, 200, 83, 0.1);
        }
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            .metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>
            <span class="icon">üìä</span>
            AirPlay HLS Proxy Monitor
        </h1>
        <div class="header-actions">
            <button class="btn btn-clear" onclick="clearStats()" title="Clear all statistics">
                üóëÔ∏è Clear Stats
            </button>
            <div class="status-badge disconnected" id="connection-status">
                <span class="status-dot"></span>
                <span id="connection-text">Connecting...</span>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="grid">
            <!-- Active Sessions -->
            <div class="card">
                <div class="card-header">
                    <h2>Active Sessions</h2>
                    <span id="session-count" class="stat-value" style="font-size: 1.5em;">0</span>
                </div>
                <div class="card-body sessions-list" id="sessions-list">
                    <div class="empty-state">
                        <div class="icon">üé¨</div>
                        <p>No active sessions</p>
                    </div>
                </div>
            </div>
            
            <!-- Request Stats -->
            <div class="card">
                <div class="card-header">
                    <h2>Request Statistics</h2>
                </div>
                <div class="card-body">
                    <div class="stat-value" id="total-requests">0</div>
                    <div class="stat-label">Total Requests</div>
                    <div class="metrics-grid">
                        <div class="metric-item">
                            <div class="metric-value" id="m3u8-requests">0</div>
                            <div class="metric-label">M3U8 Manifests</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="ts-requests">0</div>
                            <div class="metric-label">TS Segments</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="other-requests">0</div>
                            <div class="metric-label">Other</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Bandwidth -->
            <div class="card">
                <div class="card-header">
                    <h2>Bandwidth</h2>
                </div>
                <div class="card-body">
                    <div class="stat-value" id="total-bandwidth">0 B</div>
                    <div class="stat-label">Total Data Transferred</div>
                    <div class="metrics-grid">
                        <div class="metric-item">
                            <div class="metric-value" id="bandwidth-rate">0 B/s</div>
                            <div class="metric-label">Current Rate</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="avg-segment-size">0 B</div>
                            <div class="metric-label">Avg Segment</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="requests-per-min">0</div>
                            <div class="metric-label">Req/min</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Request Rate Chart -->
            <div class="card full-width">
                <div class="card-header">
                    <h2>Request Rate (Last 60 seconds)</h2>
                </div>
                <div class="card-body">
                    <div class="chart-container" id="rate-chart">
                        <!-- Chart bars will be added dynamically -->
                    </div>
                </div>
            </div>
            
            <!-- Live Traffic Feed -->
            <div class="card full-width">
                <div class="card-header">
                    <h2>Live Traffic Feed <span id="filter-indicator" style="font-size:0.8em;color:#1da1f2;"></span></h2>
                    <a href="/" class="nav-link">‚Üê Back to Player</a>
                </div>
                <div class="card-body traffic-feed" id="traffic-feed">
                    <div class="empty-state">
                        <div class="icon">üì°</div>
                        <p>Waiting for traffic...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>
    
    <script>
        // WebSocket connection for monitoring
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;
        let selectedSessionId = null;
        
        // Metrics state
        const metrics = {
            totalRequests: 0,
            m3u8Requests: 0,
            tsRequests: 0,
            otherRequests: 0,
            totalBytes: 0,
            recentRequests: [], // timestamps of recent requests
            rateHistory: new Array(60).fill(0), // requests per second for last 60 seconds
            sessions: {}
        };
        
        // Traffic history (last 100 entries)
        const trafficHistory = [];
        const maxTrafficEntries = 100;
        
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show' + (type === 'success' ? ' success' : '');
            setTimeout(() => {
                toast.className = 'toast';
            }, 3000);
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }
        
        function formatTime(date) {
            return date.toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function getStreamUrl(session, token) {
            // Extract manifest path from base_url
            const baseUrl = window.location.origin;
            // For demo session, use a known path
            if (session.session_id && session.session_id.includes('demo')) {
                return `${baseUrl}/stream/x36xhzz.m3u8?token=${token}`;
            }
            // For other sessions, construct a generic path
            return `${baseUrl}/stream/?token=${token}`;
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard!', 'success');
            }).catch(() => {
                showToast('Failed to copy', 'error');
            });
        }
        
        function clearStats() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ action: 'clear' }));
                
                // Clear local state
                metrics.totalRequests = 0;
                metrics.m3u8Requests = 0;
                metrics.tsRequests = 0;
                metrics.otherRequests = 0;
                metrics.totalBytes = 0;
                metrics.recentRequests = [];
                metrics.rateHistory = new Array(60).fill(0);
                trafficHistory.length = 0;
                
                // Clear UI
                document.getElementById('traffic-feed').innerHTML = `
                    <div class="empty-state">
                        <div class="icon">üì°</div>
                        <p>Statistics cleared. Waiting for traffic...</p>
                    </div>
                `;
                
                updateUI();
                updateRateChart();
                showToast('Statistics cleared', 'success');
            }
        }
        
        function updateUI() {
            // Update stats
            document.getElementById('total-requests').textContent = metrics.totalRequests.toLocaleString();
            document.getElementById('m3u8-requests').textContent = metrics.m3u8Requests.toLocaleString();
            document.getElementById('ts-requests').textContent = metrics.tsRequests.toLocaleString();
            document.getElementById('other-requests').textContent = metrics.otherRequests.toLocaleString();
            document.getElementById('total-bandwidth').textContent = formatBytes(metrics.totalBytes);
            
            // Calculate rate (requests in last 60 seconds)
            const now = Date.now();
            metrics.recentRequests = metrics.recentRequests.filter(t => now - t < 60000);
            const reqPerMin = metrics.recentRequests.length;
            document.getElementById('requests-per-min').textContent = reqPerMin;
            
            // Calculate bandwidth rate (bytes in last 5 seconds / 5)
            const recentBytes = trafficHistory
                .filter(t => now - new Date(t.timestamp).getTime() < 5000)
                .reduce((sum, t) => sum + (t.bytes || 0), 0);
            document.getElementById('bandwidth-rate').textContent = formatBytes(recentBytes / 5) + '/s';
            
            // Average segment size
            const segmentRequests = trafficHistory.filter(t => t.path && (t.path.endsWith('.ts') || t.path.endsWith('.m4s')));
            if (segmentRequests.length > 0) {
                const avgSize = segmentRequests.reduce((sum, t) => sum + (t.bytes || 0), 0) / segmentRequests.length;
                document.getElementById('avg-segment-size').textContent = formatBytes(avgSize);
            }
            
            // Update session count
            document.getElementById('session-count').textContent = Object.keys(metrics.sessions).length;
        }
        
        function updateRateChart() {
            const chart = document.getElementById('rate-chart');
            const maxRate = Math.max(...metrics.rateHistory, 1);
            
            chart.innerHTML = metrics.rateHistory.map((rate, i) => {
                const height = (rate / maxRate) * 100;
                return `<div class="chart-bar" style="height: ${Math.max(height, 2)}%" title="${rate} req/s"></div>`;
            }).join('');
        }
        
        let selectedSessionToken = null;
        
        function selectSession(sessionId, token) {
            if (selectedSessionId === sessionId) {
                // Deselect if clicking same session
                selectedSessionId = null;
                selectedSessionToken = null;
            } else {
                selectedSessionId = sessionId;
                selectedSessionToken = token;
            }
            
            // Update filter indicator
            const indicator = document.getElementById('filter-indicator');
            if (selectedSessionId) {
                indicator.textContent = `(filtering: ${selectedSessionId.substring(0, 16)}...)`;
            } else {
                indicator.textContent = '';
            }
            
            updateSessionsList(metrics.sessions);
            refreshTrafficFeed();
        }
        
        function refreshTrafficFeed() {
            // Re-render traffic feed with current filter
            const feed = document.getElementById('traffic-feed');
            const filtered = selectedSessionToken 
                ? trafficHistory.filter(t => t.token === selectedSessionToken)
                : trafficHistory;
            
            if (filtered.length === 0) {
                feed.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">üì°</div>
                        <p>${selectedSessionId ? 'No traffic for selected session' : 'Waiting for traffic...'}</p>
                        ${selectedSessionId ? '<p style="margin-top:8px;font-size:0.8em;">Click session again to show all traffic</p>' : ''}
                    </div>
                `;
                return;
            }
            
            feed.innerHTML = filtered.map(entry => {
                const isError = entry.status && entry.status >= 400;
                const statusClass = entry.status ? `s${Math.floor(entry.status / 100)}xx` : '';
                const time = entry.timestamp ? new Date(entry.timestamp) : new Date();
                const tokenDisplay = entry.token_short || (entry.token ? entry.token.substring(0, 8) + '...' : '');
                
                return `
                    <div class="traffic-item${isError ? ' error' : ''}">
                        <span class="traffic-time">${formatTime(time)}</span>
                        <span class="traffic-method ${entry.method || 'GET'}">${entry.method || 'GET'}</span>
                        <span class="traffic-path" title="${escapeHtml(entry.path || '')}">${escapeHtml(entry.path || 'N/A')}</span>
                        ${entry.status ? `<span class="traffic-status ${statusClass}">${entry.status}</span>` : ''}
                        <span class="traffic-size">${entry.bytes ? formatBytes(entry.bytes) : '-'}</span>
                        <span class="traffic-token">${escapeHtml(tokenDisplay)}</span>
                    </div>
                `;
            }).join('');
        }
        
        function updateSessionsList(sessions) {
            const list = document.getElementById('sessions-list');
            
            if (!sessions || Object.keys(sessions).length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">üé¨</div>
                        <p>No active sessions</p>
                    </div>
                `;
                return;
            }
            
            const now = new Date();
            const baseUrl = window.location.origin;
            
            list.innerHTML = Object.entries(sessions).map(([id, session]) => {
                const expiresAt = new Date(session.expires_at);
                const minutesLeft = Math.max(0, Math.round((expiresAt - now) / 60000));
                const isDemo = id.includes('demo');
                const isExpiring = minutesLeft < 5 && !isDemo;
                const isSelected = id === selectedSessionId;
                
                let statusClass = 'active';
                let statusText = 'Active';
                if (isDemo) {
                    statusClass = 'demo';
                    statusText = 'Demo';
                } else if (isExpiring) {
                    statusClass = 'expiring';
                    statusText = `${minutesLeft}m left`;
                }
                
                // Use full token from session data
                const fullToken = session.token || '';
                const tokenShort = session.token_short || fullToken.substring(0, 8) + '...';
                
                // Construct stream URL using the manifest_path stored in session
                let streamPath = session.manifest_path || (isDemo ? 'x36xhzz.m3u8' : null);
                const streamUrl = streamPath ? `${baseUrl}/stream/${streamPath}?token=${fullToken}` : null;
                
                return `
                    <div class="session-item ${isSelected ? 'selected' : ''}" onclick="selectSession('${escapeHtml(id)}', '${escapeHtml(fullToken)}')">
                        <div class="session-header">
                            <span class="session-id">${escapeHtml(id)}</span>
                            <span class="session-status ${statusClass}">${statusText}</span>
                        </div>
                        <div class="session-details">
                            <p><span class="label">Base URL:</span> <span style="word-break: break-all;">${escapeHtml(session.base_url || 'N/A')}</span></p>
                            ${streamPath ? `<p><span class="label">Manifest:</span> <span style="word-break: break-all;">${escapeHtml(streamPath)}</span></p>` : ''}
                            <p><span class="label">Token:</span> <code style="word-break: break-all;">${escapeHtml(fullToken)}</code></p>
                            ${streamUrl ? `<p><span class="label">Stream URL:</span> <code style="word-break: break-all; font-size: 0.75em;">${escapeHtml(streamUrl)}</code></p>` : ''}
                            <p><span class="label">Created:</span> ${session.created_at ? new Date(session.created_at).toLocaleString() : 'N/A'}</p>
                            <p><span class="label">Expires:</span> ${session.expires_at ? new Date(session.expires_at).toLocaleString() : 'N/A'}</p>
                        </div>
                        <div class="session-actions">
                            ${streamUrl ? `
                            <a href="${streamUrl}" target="_blank" class="session-link" title="Open stream in new tab">
                                ‚ñ∂Ô∏è Open Stream
                            </a>
                            <span class="session-link copy" onclick="event.stopPropagation(); copyToClipboard('${escapeHtml(streamUrl)}')" title="Copy stream URL">
                                üìã Copy Stream URL
                            </span>
                            ` : ''}
                            <span class="session-link copy" onclick="event.stopPropagation(); copyToClipboard('${escapeHtml(fullToken)}')" title="Copy token">
                                üîë Copy Token
                            </span>
                            ${isDemo ? `
                            <a href="${baseUrl}/" class="session-link" title="Go to player page">
                                üé¨ Player Page
                            </a>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function addTrafficEntry(entry) {
            // Add to history
            trafficHistory.unshift(entry);
            while (trafficHistory.length > maxTrafficEntries) {
                trafficHistory.pop();
            }
            
            // Update metrics
            metrics.totalRequests++;
            metrics.recentRequests.push(Date.now());
            
            if (entry.path) {
                if (entry.path.endsWith('.m3u8')) {
                    metrics.m3u8Requests++;
                } else if (entry.path.endsWith('.ts') || entry.path.endsWith('.m4s')) {
                    metrics.tsRequests++;
                } else {
                    metrics.otherRequests++;
                }
            }
            
            if (entry.bytes) {
                metrics.totalBytes += entry.bytes;
            }
            
            // If filtering by session, only show if matches
            if (selectedSessionToken && entry.token !== selectedSessionToken) {
                updateUI();
                return;
            }
            
            const feed = document.getElementById('traffic-feed');
            
            // Remove empty state if present
            if (feed.querySelector('.empty-state')) {
                feed.innerHTML = '';
            }
            
            // Create traffic entry element
            const div = document.createElement('div');
            const isError = entry.status && entry.status >= 400;
            div.className = 'traffic-item' + (isError ? ' error' : '');
            
            const statusClass = entry.status ? `s${Math.floor(entry.status / 100)}xx` : '';
            const time = entry.timestamp ? new Date(entry.timestamp) : new Date();
            const tokenDisplay = entry.token_short || (entry.token ? entry.token.substring(0, 8) + '...' : '');
            
            div.innerHTML = `
                <span class="traffic-time">${formatTime(time)}</span>
                <span class="traffic-method ${entry.method || 'GET'}">${entry.method || 'GET'}</span>
                <span class="traffic-path" title="${escapeHtml(entry.path || '')}">${escapeHtml(entry.path || 'N/A')}</span>
                ${entry.status ? `<span class="traffic-status ${statusClass}">${entry.status}</span>` : ''}
                <span class="traffic-size">${entry.bytes ? formatBytes(entry.bytes) : '-'}</span>
                <span class="traffic-token">${escapeHtml(tokenDisplay)}</span>
            `;
            
            feed.insertBefore(div, feed.firstChild);
            
            // Limit displayed entries
            while (feed.children.length > maxTrafficEntries) {
                feed.removeChild(feed.lastChild);
            }
            
            updateUI();
        }
        
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/monitor`;
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    console.log('Monitor WebSocket connected');
                    reconnectAttempts = 0;
                    
                    const status = document.getElementById('connection-status');
                    status.className = 'status-badge connected';
                    document.getElementById('connection-text').textContent = 'Connected';
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        switch (data.type) {
                            case 'ping':
                                // Ignore ping messages
                                break;
                            case 'sessions':
                                metrics.sessions = data.sessions || {};
                                updateSessionsList(data.sessions);
                                break;
                            case 'traffic':
                                addTrafficEntry(data);
                                break;
                            case 'stats':
                                // Initial stats sync
                                if (data.total_requests !== undefined) metrics.totalRequests = data.total_requests;
                                if (data.total_bytes !== undefined) metrics.totalBytes = data.total_bytes;
                                if (data.m3u8_requests !== undefined) metrics.m3u8Requests = data.m3u8_requests;
                                if (data.ts_requests !== undefined) metrics.tsRequests = data.ts_requests;
                                if (data.other_requests !== undefined) metrics.otherRequests = data.other_requests;
                                updateUI();
                                break;
                            case 'reset':
                                // Stats were cleared on server
                                metrics.totalRequests = 0;
                                metrics.m3u8Requests = 0;
                                metrics.tsRequests = 0;
                                metrics.otherRequests = 0;
                                metrics.totalBytes = 0;
                                updateUI();
                                break;
                            default:
                                console.log('Unknown message type:', data.type);
                        }
                    } catch (e) {
                        console.error('Failed to parse message:', e);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('Monitor WebSocket error:', error);
                };
                
                ws.onclose = (event) => {
                    console.log('Monitor WebSocket closed:', event.code, event.reason);
                    
                    const status = document.getElementById('connection-status');
                    status.className = 'status-badge disconnected';
                    document.getElementById('connection-text').textContent = 'Disconnected';
                    
                    // Attempt reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                        console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts})`);
                        setTimeout(connectWebSocket, delay);
                    }
                };
            } catch (e) {
                console.error('Failed to create WebSocket:', e);
                setTimeout(connectWebSocket, 3000);
            }
        }
        
        // Update rate history every second
        setInterval(() => {
            const now = Date.now();
            const recentCount = metrics.recentRequests.filter(t => now - t < 1000).length;
            metrics.rateHistory.shift();
            metrics.rateHistory.push(recentCount);
            updateRateChart();
        }, 1000);
        
        // Connect on page load
        connectWebSocket();
        
        // Initial UI update
        updateUI();
        updateRateChart();
    </script>
</body>
</html>

